module Polevault
  class Migrator
    include Helpers

    attr_reader :path, :client

    def initialize(config: nil, client: nil)
      # if config is nil we can assume Figly has loaded
      Figly.load_file(config) if config
      @client = client if client
      @path = File.expand_path(Figly::Settings.migrations_path || "#{Polevault.root}/migrations")
    end

    # This must be run from a root account that has access to the root token in
    # the kv store.
    def migrate
      count = 0
      client.token = kv.read(root_key_prefix, shard: 'root') if client.token.nil?
      with_lock do
        Dir["#{path}/*.rb"].each do |file|
          version, class_name = parse_migration(file)
          next if latest >= version
          puts "Starting migration #{file}"
          count += 1
          require file
          klass = Object.const_get("::#{class_name}")
          klass.new(client, fig, kv).migrate

          # All of the client methods will properly raise exceptions, which will
          # halt this loop. We don't want to swallow that backtrace so we'll just
          # let the error pass along
          update_version(version)
        end
      end
      if count.positive?
        puts "Ran #{count} migration#{'s' unless count == 1 }."
      else
        puts "No migrations to run. Up to date"
      end
    end

    def parse_migration(file)
      fname = File.split(file).last
      version, *rest = fname.split('_')
      class_name = rest.map(&:capitalize).join
      class_name.gsub!('.rb', '')
      [version.to_i, class_name]
    end

    def update_version(version)
      client.logical.write(key, latest: version)
    end

    def with_lock
      lock_key = 'secret/_migration_lock'.freeze
      resp = client.logical.read(lock_key)
      return if resp && resp.data[:value]
      client.logical.write(lock_key, value: true)
      yield
      client.logical.delete(lock_key)
    end

    def latest
      @latest ||= client.logical.read(key).data[:latest].to_i rescue 0
    end

    def key
      fig.migration_key || 'secret/_migration'
    end

    def generate_migration(name)
      name = name.match(/\w+/).to_s
      filename = File.join(path, "#{Time.now.to_i}_#{name}.rb")
      class_name = camelcase(name)

      template = <<-TEMPLATE
require 'polevault/migration'

class #{class_name} < Polevault::Migration
  def migrate
    # NOTE: Within this class you have access to the following variables:
    #
    # vault: Vault::Client instance configured with config
    #   This which will have access to setup your
    #   Vault node through the root token generated by init. See
    #   https://github.com/hashicorp/vault-ruby for API docs
    # config: Figly::Settings hash that has config accessible via dot operator.
    #   see http://github.com/onetwopunch/figly for details
    # kv: The kv store you specified in your config with methods read/write.
    #
    # i.e.
    # vault.logical.write('secret/test', value: config.custom.secret_value)
  end
end

TEMPLATE
      File.open(filename, 'w') do |file|
        file.write(template)
      end
      filename
    end
  end
end
